VHDL
====

library IEEE; use IEEE.std_logic_1164.all; use IEEE.numeric_std.all; use IEEE.std_logic_unsigned.all; --use IEEE.std_logic_arith.all;  entity Nexys2 is   generic(inpnums: integer := 32;   addrwdth: integer := 5);   port(led: out std_logic_vector(7 downto 0);   seg: out std_logic_vector(6 downto 0);   dp: out std_logic;   an: out std_logic_vector(3 downto 0);   clk: in std_logic;   sw: in std_logic_vector(7 downto 0);   btn: in std_logic_vector(3 downto 0)); end Nexys2;  architecture behavorial of Nexys2 is --variable wdth: integer := 16; signal rst, rfd, we, en1, en2, pr, ce, flag: std_logic; --signal flag: std_logic := '0'; signal num: std_logic_vector(1 downto 0); --signal stp1, stp2: std_logic; signal half, quotient, di1, di2, do1, do2: std_logic_vector(31 downto 0) := (others => '0'); signal temp1, addr1, addr2: std_logic_vector(addrwdth-1 downto 0); signal digit1, digit2, digit3, digit4: std_logic_vector(7 downto 0);  signal an_sig: std_logic_vector(3 downto 0); signal tempcount: std_logic_vector(9 downto 0); --signal addrcount1, addrcount2: std_logic_vector(4 downto 0); signal outp: std_logic_vector(15 downto 0) := (others => '0'); signal dividend: std_logic_vector(31 downto 0); signal divisor, fractional: std_logic_vector(11 downto 0);  component DivComp   port (   clk: in std_logic;   ce: in std_logic;   rfd: out std_logic;   dividend: in std_logic_VECTOR(31 downto 0);   divisor: in std_logic_VECTOR(11 downto 0);   quotient: out std_logic_VECTOR(31 downto 0);   fractional: out std_logic_VECTOR(11 downto 0)); end component; ---FPGA express black box declaration attribute fpga_dont_touch: string; attribute fpga_dont_touch of DivComp: component is "true"; --Simplify black box declaration attribute syn_black_box: boolean; attribute syn_black_box of DivComp: component is true;  component RAM is   generic(width1: integer := 5;   inpnums: integer := 32);   port (clk: in std_logic;   we : in std_logic;   en : in std_logic;   addr: in std_logic_vector(width1-1 downto 0);   di : in std_logic_vector(31 downto 0);   do : out std_logic_vector(31 downto 0)); end component;  component ROM is   generic(width1: integer := 5;   inpnums: integer := 32);   port (clk: in std_logic;   we : in std_logic;   en : in std_logic;   addr: in std_logic_vector(width1-1 downto 0);   di : in std_logic_vector(31 downto 0);   do : out std_logic_vector(31 downto 0)); end component;  begin   rst &lt;= btn(0);   an &lt;= an_sig;      ROM_I: ROM port map(clk, we, en1, addr1, di1, do1); --1st 500 primes   RAM_II: RAM port map(clk, we, en2, addr2, di2, do2); --N 32 inputs   DIVS : DivComp     port map (       clk => clk,       ce => ce,       rfd => rfd,       dividend => dividend,       divisor => divisor,       quotient => quotient,       fractional => fractional);         p1: process(rst, clk)   begin     en2 &lt;= '1';     en1 &lt;= '1';     if(rst = '1') then       addr1 &lt;= (others => '0');       addr2 &lt;= (others => '0');       pr &lt;= '0';       flag &lt;= '0';     elsif(clk'event and clk = '1') then       if(do2(4 downto 0) = "0010" or do2(4 downto 0) = "0011" or do2(4 downto 0) = "0101") then         pr &lt;= '1'; --make np = '1'?? so that it doesn't look for an output anymore?         outp(addrwdth-1 downto 0) &lt;= addr2 + 1; --prime numbe rif 2, 3, or 5       elsif(do2(4 downto 0) = "0100") then         --np &lt;= '1';         addr2 &lt;= addr2 + 1;         addr1 &lt;= (others => '0');       elsif(do2 = do1) then --if #in RAM matches # in ROM, it is a prime         outp(addrwdth-1 downto 0) &lt;= addr2;       else         if(num = "00") then --part of stalling. don't want half to change yet         half &lt;= '0' &amp; do2(31 downto 1);         ce &lt;= '1';         end if;         if(do1 &lt; half and pr = '0') then           dividend &lt;= do2;           divisor &lt;= do1(11 downto 0);           flag &lt;= '1';               if(num = 2) then                 flag &lt;= '0';                 if(fractional /= 0 and do1 /= X"00000083") then --if there is a remainder and not last Rom #                   temp1 &lt;= addr2;                   addr1 &lt;= addr1 + 1;                 elsif(fractional /= 0) then --if there is a remainder and last Rom #                   pr &lt;= '1';                   outp(addrwdth-1 downto 0) &lt;= temp1;                                   elsif(fractional = 0) then --if no remainder go to next ROm #                   --np &lt;= '1';                   addr1 &lt;= (others => '0');                   addr2 &lt;= addr2 + 1;                 end if;                 --if(do1 = X"00000083") then                   --if(np = '0') then                     --outp(addrwdth-1 downto 0) &lt;= temp1;                   --else                     --addr2 &lt;= addr2 + 1;                   --end if;                 --end if;               end if; --end if(num = 2)         elsif(pr = '1') then           addr2 &lt;= addr2 + 1;         elsif(do1 >= half and num = 2) then           outp(addrwdth-1 downto 0) &lt;= addr2;                   end if;       end if;     end if;   end process;      number: process(rst, clk, flag)   begin     if(rst = '1') then       num &lt;= (others => '0');     elsif(clk'event and clk = '1') then       if(flag = '1') then         num &lt;= num + 1;       else         num &lt;= "00";       end if;     end if;   end process;      counters: process(rst, clk)   begin     if(rst = '1') then       tempcount &lt;= (others => '0');     elsif(clk'event and clk = '1') then       tempcount &lt;= tempcount + '1';       if(tempcount = "1111111111") then         tempcount &lt;= (others => '0');       end if;     end if;   end process;   